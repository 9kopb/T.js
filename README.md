# T.js – библиотека для локализации JS-приложений

T.js берёт на себя все задачи, связанные с выводом локализованного текста:

- зависимость от числа, пола и падежа
- правильное склонение русских имён
- форматирование даты, времени и чисел
- встраивание одних строк в другие
- инлайновый перевод
- (опционально) приведение всех строк в соответствие с типографическими правилами

Ниже — подробнее.

## Использование

Для использования библиотеки её необходимо подключить, а затем добавить в неё необходимые локализации.

Добавление локализации производится вызовом `T.define()` и его имеет смысл вынести в отдельные файлы `lang.ru.js`, `lang.en.js` и т.д. (чтобы их можно было подключать по отдельности). Если локализация небольшая, все переводы можно объединить и в один файл (`lang.js`). Файл с текущим перевод также следует подключить обычным способом (или загрузить и выполнить асинхронно).

После загрузки библиотеки необходимо указать текущий язык:
```js
T.lang('ru');
```

Пример файла перевода:

```js
T.define({
  ru: {
    $aux: {
      your: {
        ins:        { $plural: { one: 'вашей', other: 'вашими' } },
        acc:        { $plural: { one: 'вашу', other: 'ваших' } },
      },
      uploaded:     { $plural: { one: 'загрузил', other: 'загрузили' } },
      liked:        { $gender: { m: 'оценил', f: 'оценила' } },
      
      users:        { $plural: { one: '{} пользователь', few: '{} пользователя', other: '{} пользователей' } },
      photos: {
        nom:        { $plural: { one: 'фотография', few: 'фотографии', other: 'фотографий' } },
        gen:        { $plural: { one: 'фотографии', few: 'фотографий', other: 'фотографий' } },
        dat:        { $plural: { one: 'фотографии', few: 'фотографиям', other: 'фотографиям' } },
        acc:        { $plural: { one: 'фотографию', few: 'фотографии', other: 'фотографий' } },
        ins:        { $plural: { one: 'фотографией', few: 'фотографиями', other: 'фотографиями' } },
        abl:        { $plural: { one: 'фотографии', few: 'фотографиях', other: 'фотографиях' } },
      },

      codes: {
        200:        'OK',
        300:        'перенаправление',
        400:        'не существует',
        500:        'ошибка',
      },
    },

    ok:            'OK',
    cancel:        'отмена',
    online:        'онлайн {>users}',

    newsfeed: {
      uploaded:    '{>users users} {>uploaded users} {>photos.acc photos}',
      press_ok:    'нажмите «{>ok}»',
      status:      'статус {code}: {>codes code}',
    },
  },
});
```

Подробнее его структура рассмотрена ниже.

Перевод строки с ключом `newsfeed.uploaded`:
```js
el.innerHTML = T('newsfeed.uploaded', { users: 5, photos: 21 });
```

Результат:
```html
5 пользователей загрузили 21 фотографию
```

## Структура файла перевода

JS-объект, передаваемый в функцию `T.define()` должен содержать один или несколько полей, название каждого из которых соответствует двухбуквенному коду языка (`ru`, `en`), а значение является объектом, который описывает перевод на указанный язык. Внутри такого объекта содержатся либо непосредственно пары ключ-значение, либо вложенные объекты, либо специальные поля. Вложенные объекты могут быть любой глубины (и к ним можно обращаться через точечную нотацию), но рекомендуется использовать только один уровень вложенности — на верхнем уровне общие для всего приложения строки, остальные сгруппированы по разделам.

### Формат подстановок

Каждому ключу в переводе соответствует строка, которая может содержать два вида подстановок: данные и другие строки перевода.

Данные передаются в виде объекта вторым параметром в функцию `T`. Чтобы подставить это значение целиком, используйте фигурные скобки: `{}`. Для того, чтобы обратиться к какому-то из внутренних полей, в фигурных скобках пропишите «путь» к нему: `{user.name}`.

Кроме того, внутрь строк можно подставлять другие строки из того же перевода. Делается это так:
`{>key param1 param2 name=param3}`
Здесь `key` – подставляемая строка, `param1`, `param2` и `param3` – поля данных, которые нужно передать в неё (при этом значение поля `param3` станет доступно как `name`). По умолчанию в «дочернюю» строку передаются те же данные, что были переданы родительской.

### Зависимость от числа

Часто возникает необходимость сделать строку зависящей от переданного ей числа. В этом случае различные варианты строки оборачиваются в структуру `$plural`:
```js
users: {
  $plural: {
    one: '{} пользователь',
    few: '{} пользователя',
    other: '{} пользователей'
  }
}
```

Поля `zero`, `one`, `few`, `many` и `other` являются зарезервированными и соответствуют значениям, описанным в документе
http://www.unicode.org/cldr/charts/27/supplemental/language_plural_rules.html

Кроме того, можно указать варианты и для конкретных значений.

В данный момент в библиотеку встроены правила для русского и английского языка, но для конкретного перевода можно написать собственную функцию определения категории по числу и поместить её в виде поля `$plural` в корне объекта, описывающего перевод.

При обращении к ключу, содержащему внутри себя структуру `$plural`, будет автоматически выбран соответствующий вариант на основании либо поля `n`, если передан объект, либо, если передано одно число, самого числа.

### Зависимость от пола

Аналогично зависимости от числа, можно помечать строку как зависящую от пола при помощи поля `$gender`:
```js
liked: {
  $gender: { 
    m: 'оценил',
    f: 'оценила'
  }
}
```

Если у входного объекта поле `g` (или сам объект) начинается с буквы `f` или имеет значение 1, будет выбран вариант, соответствующий женскому полу, в противном случае — мужскому.

### Зависимость от падежа

Иногда удобно записать одну строку в разных падежах чтобы использовать её внутри других строк (в составе предложений). Для этого можно просто использовать вложенный объект:
```js
your: {
  nom:        { $plural: { one: 'ваша', other: 'ваши' } },
  gen:        { $plural: { one: 'вашей', other: 'ваших' } },
  dat:        { $plural: { one: 'вашей', other: 'вашим' } },
  acc:        { $plural: { one: 'вашу', other: 'ваших' } },
  ins:        { $plural: { one: 'вашей', other: 'вашими' } },
  abl:        { $plural: { one: 'вашей', other: 'ваших' } },
}
```

Тогда значение, естественно, можно получить как `{>your.acc}`. Однако иногда возникает ситуация, когда нужно просклонять входные данные, а не строки перевода. Чаще всего это необходимо для имён собственных (например, для фразы «Олегу понравились 2 ваших фотографии»). Для этого случая доступны специальные функции `$name`, `$surname` и `$patronym`. Обращаться к ним следует так, словно это обычные подставляемые строки: `{$name.dat user.firstName} {$surname.dat user.lastName}`. В данный момент реализована поддержка только русских имён, фамилий и отчеств (разумеется, для английского и многих других языков такой проблемы не стоит).

При желании, функции `$name`, `$surname` и `$patronym` можно переопределить (аналогично `$plural`) – объявив их в корне объекта, описывающего перевод. Первым параметром в них передается имя, вторым  — падеж, указанный после точки.

Кроме того, можно определять и собственные функции, которые будут вызываться аналогичным образом. Если название функции не начинается с `$`, при обращении к ней нужно ставить знак `>` в начале (как при подстановке любой другой строки), в противном случае он опционален. Первый параметр это всегда данные, «прокинутые» из родительской строки; второй, третий и так далее — то, что стоит после первой, второй (и так далее) точки за именем функции. То есть, подстановка `{>testFunc.optA.optB val1 val2 xxx=val3}` превратится в вызов `testFunc({ 0: val1, 1: val2, xxx: val3 }, 'optA', 'optB')`.

### Зависимость от входных данных



### Форматирование даты и времени

### Форматирование чисел

### Типографика

http://mdash.ru/rules.html
http://www.artlebedev.ru/kovodstvo/sections/62/ (и Ководство в целом)
https://github.com/typograf/typograf/blob/dev/docs/RULES.ru.md



## Интерфейс для перевода

Библиотека не берёт на себя ответственность за непосредственно создание и изменение переводов, но предоставляет два интерфейса, упрощающих эти процессы.

Вызов `T.showAllKeys(path)` откроет попап-окно со списком всех строк в текущем переводе. Опциональным параметром `path` можно отфильтровать список, показав только ключи, находящиеся по указанному пути. Вызов `T.showKey(key)` откроет попап-окно для редактирования указанной строки.

Чтобы обработать нажатие кнопки «Сохранить», предварительно необходимо повесить обработчик: `T.addUpdateListener(func)`. В функцию `func` будет передан объект вида
```js
{
  ru: {
    updatedKey: 'new_value',
    addedKey: 'value',
    removedKey: null,
  }
}
```

Ответственность за сохранение изменений (запрос к серверу и серверный обработчик) лежит на вашей стороне. Разумеется, не забудьте также позаботиться о проверке прав на изменение строк на серверной стороне.

Чтобы процесс перевода был более комфортным, предлагается также «инлайн-интерфейс» для переводчиков. Чтобы перевести библиотеку в такой режим, сделайте вызов `T.toggleInlineTranslation(true)` перед отрисовкой приложения (или перерисуйте его заново). В этом режиме все строки будут обернуты в следующий HTML-код:
```html
<span class="inline-translation" style="border-bottom: 1px dotted #333; cursor: pointer" onclick="T.showKey('key'); event.stopPropagation(); return false;">...</span>
```

Чтобы запретить оборачивание отдельных строк в этот код, при вызове `T('key', ...)` допишите восклицательный знак после имени ключа: `T('key!', ...)`.

После этого при клике по любому переведенному тексту будет открываться попап для перевода соответствующего ключа. При сохранении будет сделан тот же вызов обработчика, что указано выше.

При использовании инлайн-интерфейса в фреймворках, следящих за безопасностью выводимых строк нужно применять средства для подстановки «небезопасного HTML» (например, в Angular вызывать $sce.trustAsHtml и использовать директиву `ng-bind-html`). В свою очередь, T.js по умолчанию делает безопасными все входные данные (но не сами строки — в них можно использовать HTML-тэги), заменяя < и > на &lt; и &gt; соответственно.